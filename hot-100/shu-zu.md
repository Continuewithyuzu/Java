---
description: 了解一下动态规划的底层机制
---

# 数组

## Q1、List vals = new ArrayList();h和 int \[]arr = new int\[100000];两种定义数组的方法有什么不同？

两种定义方式的主要区别如下：

#### 1. **容量与可变性**

* **固定大小的数组** (`int[] arr = new int[100000];`):
  * **固定容量**：数组在创建时就需要指定长度（例如，这里是 100000），容量是固定的，无法在运行时动态调整。
  * **容量限制**：如果数据量超过了预先定义的容量，就会发生 `ArrayIndexOutOfBoundsException` 异常。
* **动态数组（列表）** (`List<Integer> vals = new ArrayList<Integer>();`):
  * **动态容量**：`ArrayList` 是一个可变长度的集合，初始容量可以不指定，默认容量为 10。随着元素的添加，`ArrayList` 会自动扩容。
  * **自动扩容**：当容量不足时，`ArrayList` 会创建一个更大的内部数组并将原有元素复制过去，这个过程对开发者是透明的。

#### 2. **数据类型**

* **基本类型数组** (`int[]`):
  * **存储基本类型**：数组可以直接存储基本数据类型，如 `int`，不涉及对象的装箱和拆箱。
  * **内存连续**：数组的元素在内存中是连续存储的，访问速度快。
* **泛型列表** (`List<Integer>`):
  * **存储对象类型**：`ArrayList` 只能存储对象类型，对于基本类型需要进行 **自动装箱**（将 `int` 转换为 `Integer` 对象）。
  * **装箱/拆箱开销**：装箱和拆箱会带来一定的性能开销，可能影响效率。

#### 3. **功能与操作**

* **数组**:
  * **有限的操作**：提供基本的索引访问和长度属性，没有丰富的内置方法。
  * **线程安全**：数组本身不是线程安全的，需要开发者自行处理。
* **`ArrayList`**:
  * **丰富的方法**：提供诸如 `add()`、`remove()`、`get()`、`size()` 等方法，方便对集合进行操作。
  * **灵活性**：支持集合框架的各种特性，如迭代器、集合算法等。

#### 4. **性能考虑**

* **数组**:
  * **访问速度快**：由于数据连续存储，索引访问速度非常快。
  * **内存占用少**：存储基本类型，内存开销较小。
* **`ArrayList`**:
  * **访问速度稍慢**：由于存储的是对象引用，且需要装箱/拆箱，访问速度可能稍逊于数组。
  * **内存占用大**：对象引用和装箱后的对象会占用更多内存。

#### 5. **使用场景**

* **什么时候使用数组**:
  * **已知固定大小**：当数据量固定且不需要动态调整时，数组是不错的选择。
  * **性能关键**：在性能要求极高的场景下，数组可能更合适。
* **什么时候使用 `ArrayList`**:
  * **数据量不确定**：当需要存储的元素数量在运行时才知道，或者需要频繁增加/删除元素时，`ArrayList` 更方便。
  * **需要集合操作**：需要使用集合框架提供的丰富操作和算法时。

#### **在你的代码中的应用**

在你的代码中，使用 `int[] arr = new int[100000];` 存在以下问题：

* **容量限制**：如果链表长度超过 100000，就会导致数组越界。
* **浪费空间**：如果链表长度远小于 100000，预先分配的空间会被浪费。

改为使用 `List<Integer> vals = new ArrayList<Integer>();` 后：

* **避免越界**：`ArrayList` 会根据需要自动扩容，避免了数组越界的问题。
* **节省空间**：仅根据实际需要分配内存，初始容量可以较小，减少了内存浪费。

**示例代码比较**：

```java
// 使用固定大小的数组
int[] arr = new int[100000];
int i = 0;
ListNode p = head;
while (p != null) {
    if (i >= arr.length) {
        // 处理数组越界情况
        throw new RuntimeException("链表长度超过数组容量");
    }
    arr[i++] = p.val;
    p = p.next;
}
```

```java
// 使用 ArrayList
List<Integer> vals = new ArrayList<>();
ListNode p = head;
while (p != null) {
    vals.add(p.val);
    p = p.next;
}
```

**总结**：`ArrayList` 提供了更大的灵活性和安全性，适用于元素数量不确定的情况，而数组在需要高性能和固定大小的情况下更为适用。根据你的需求，使用 `ArrayList` 可以有效避免数组越界的问题，并使代码更简洁易读。



Java内存中是没有指针，看不到每个元素的地址情况，二维数组也不是连续分布的

***

## sort排序

在Java 7及以后的版本中，`Arrays`类在排序小型数组时使用的是改进后的快速排序算法，而在排序大型数组时使用的是归并排序算法。

### sort是升序排序，具体的用法有：

```java
Arrays.sort(array);
Collections.sort(list);
```

局部排序：

```java
Arrays.sort(数组名,start,end);//注意左闭右开！！！[start,end)
```

### 如果要实现降序排序，需要用Collections类的reverse方法实现

```java
Collections.reverse(Arrays.asList(arr));
```

或：

```java
Arrays.sort(arr, Collections.reverseOrder());
```
